//	Библиотека для работы с расширителем выводом iarduino_PCA9555 для Arduino: https://iarduino.ru
//  Версия: 1.0.2
//  Последнюю версию библиотеки Вы можете скачать по ссылке: https://iarduino.ru/
//  Подробное описание функций бибилиотеки доступно по ссылке: https://wiki.iarduino.ru/
//  Библиотека является собственностью интернет магазина iarduino.ru и может свободно использоваться и распространяться!
//  При публикации устройств или скетчей с использованием данной библиотеки, как целиком, так и её частей,
//  в том числе и в некоммерческих целях, просим Вас опубликовать ссылку: http://iarduino.ru
//  Автор библиотеки: Панькин Павел.
//  Если у Вас возникли технические вопросы, напишите нам: shop@iarduino.ru

#ifndef iarduino_PCA9555_h																						//
#define iarduino_PCA9555_h																						//
																												//
#if defined(ARDUINO) && (ARDUINO >= 100)																		//
#include		<Arduino.h>																						//
#else																											//
#include		<WProgram.h>																					//
#endif																											//
																												//
#include		"iarduino_PCA9555_I2C.h"																		//	Подключаем библиотеку выбора реализации шины I2C.
																												//
#if defined(TwoWire_h) || defined(__ARDUINO_WIRE_IMPLEMENTATION__) || defined(__AVR_ATmega328__) || defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega2560__) || defined(ESP8266) || defined(ESP32) || defined(ARDUINO_ARCH_RP2040) || defined(RENESAS_CORTEX_M4) // Если подключена библиотека Wire или платы её поддерживают...
#include		<Wire.h>																						//	Разрешаем использовать библиотеку Wire в данной библиотеке.
#endif																											//
#if defined( iarduino_I2C_Software_h )																			//	Если библиотека iarduino_I2C_Software подключена в скетче...
#include		<iarduino_I2C_Software.h>																		//	Разрешаем использовать библиотеку iarduino_I2C_Software в данной библиотеке.
#endif																											//
																												//
//				Адреса регистров модуля:																		//
#define			REG_PCA9555_INPUT	0x00																		//	Адрес регистра входного  порта 0. Регистр для чтения входящих  логических уровней, независимо от конфигурации выводов (вход или выход).
//				REG_PCA9555_INPUT_1	0x01																		//	Адрес регистра входного  порта 1. Регистр для чтения входящих  логических уровней, независимо от конфигурации выводов (вход или выход).
#define			REG_PCA9555_OUTPUT	0x02																		//	Адрес регистра выходного порта 0. Регистр для записи исходящих логических уровней, только для выводов сконфигурированных как выход.
//				REG_PCA9555_OUTPUT1	0x03																		//	Адрес регистра выходного порта 1. Регистр для записи исходящих логических уровней, только для выводов сконфигурированных как выход.
#define			REG_PCA9555_INVERS	0x04																		//	Адрес регистра инверсии полярности входного порта 0. Регистр содержит флаги инверсии данных порта INPUT0.
//				REG_PCA9555_INVERS1	0x05																		//	Адрес регистра инверсии полярности входного порта 1. Регистр содержит флаги инверсии данных порта INPUT1.
#define			REG_PCA9555_CONFIG	0x06																		//	Адрес регистра конфигурации порта 0. Регистр конфигурирует выводы: 0-выход, 1-вход.
//				REG_PCA9555_CONFIG1	0x07																		//	Адрес регистра конфигурации порта 1. Регистр конфигурирует выводы: 0-выход, 1-вход.
																												//
#ifndef			INPUT																							//
#define			INPUT				0																			//	Пример:   pinMode( 0, INPUT );   portMode( 0, INPUT );
#endif																											//
																												//
#ifndef			OUTPUT																							//
#define			OUTPUT				1																			//	Пример:   pinMode( 0, OUTPUT);   portMode( 0, OUTPUT);
#endif																											//
																												//
#define			pinsAll(i) (i==OUTPUT?0xFFFF:0)																	//	Пример:   portMode( 2, pinsAll(INPUT) );   portWrite( 0, pinsAll(LOW) );
																												//
class iarduino_PCA9555{																							//
	public:																										//
	/**	Конструктор класса **/																					//
		iarduino_PCA9555						(uint8_t address=0){											//	Конструктор класса														(Параметр: адрес модуля на шине I2C, если не указан (=0), то адрес будет определён).
												if(address>0x7F){ address>>=1; }								//	Корректируем адрес, если он указан с учётом бита RW.
							valAddrTemp		=	address;														//	Сохраняем переданный адрес модуля.
							selI2C			=	new iarduino_I2C_Select;										//	Переопределяем указатель selI2C на объект производного класса iarduino_I2C_Select.
		}																										//
	/**	Пользовательские функции **/																			//
		#if defined(TwoWire_h) || defined(__ARDUINO_WIRE_IMPLEMENTATION__)										//
		bool				begin				(TwoWire* i=&Wire ){ selI2C->begin(i); return _begin(); }		//	Определяем функцию инициализации модуля									(Параметр:  объект для работы с аппаратной шиной I2C).
		#endif																									//
		#if defined(iarduino_I2C_Software_h)																	//
		bool				begin				(SoftTwoWire* i   ){ selI2C->begin(i); return _begin(); }		//	Определяем функцию инициализации модуля									(Параметр:  объект для работы с программной шиной I2C).
		#endif																									//
		bool				reset				(void				);											//	Объявляем  функцию сброса модуля										(Параметр:  отсутствует).
		uint8_t				getAddress			(void				){ return valAddr;	}						//	Определяем функцию возвращающую адрес модуля на шине I2C				(Параметр:  отсутствует).
																												//
		bool				pinMode				(uint8_t, uint8_t	);											//	Объявляем  функцию конфигурирования одного вывода						(Параметры:	номер вывода 0...15, направление INPUT/OUTPUT).
		bool				digitalRead			(uint8_t			);											//	Объявляем  функцию чтения уровня с одного вывода						(Параметр:	номер вывода 0...15).
		bool				digitalWrite		(uint8_t, bool		);											//	Объявляем  функцию установки уровня на одном выводе						(Параметры:	номер вывода 0...15, логический уровень 0/1).
																												//
		bool				portMode			(uint8_t, uint16_t	);											//	Объявляем  функцию конфигурирования порта выводов						(Параметры:	номер порта 0/1/2, биты направления).
		uint16_t			portRead			(uint8_t			);											//	Объявляем  функцию чтения уровней с порта выводов						(Параметр:	номер порта 0/1/2).
		bool				portWrite			(uint8_t, uint16_t	);											//	Объявляем  функцию установки уровней порта выводов						(Параметры:	номер порта 0/1/2, логические уровни).
	private:																									//
	/**	Внутренние переменные **/																				//
		iarduino_I2C_VirtualSelect* selI2C;																		//	Объявляем  указатель  на  объект полиморфного класса iarduino_I2C_VirtualSelect, но в конструкторе текущего класса этому указателю будет присвоена ссылка на производный класс iarduino_I2C_Select.
		uint8_t				valAddrTemp		=	0;																//	Определяем переменную для хранения адреса модуля на шине I2C который был указан, но не был проверен.
		uint8_t				valAddr			=	0;																//	Определяем переменную для хранения адреса модуля на шине I2C.
		uint8_t				valOUTPUT[2]	=	{0b11111111,0b11111111};										//	Определяем массив     для хранения данных регистров выходных портов.
		uint8_t				valINVERS[2]	=	{0b00000000,0b00000000};										//	Определяем массив     для хранения данных регистров инверсии полярности входных портов.
		uint8_t				valCONFIG[2]	=	{0b11111111,0b11111111};										//	Определяем массив     для хранения данных регистров конфигурации портов.
		uint8_t				data[2];																			//	Объявляем  массив     для хранения получаемых/передаваемых данных.
	/**	Внутренние функции **/																					//
		bool				_begin				(void							);								//	Объявляем  функцию инициализации модуля									(Параметр:  отсутствует).
		bool				_readBytes			(uint8_t, uint8_t				);								//	Объявляем  функцию чтения данных в  массив  data								(Параметры: номер первого регистра, количество байт).
		bool				_writeBytes			(uint8_t, uint8_t, uint8_t=0	);								//	Объявляем  функцию записи данных из массива data								(Параметры: номер первого регистра, количество байт, номер первого элемента массива data).
};																												//
																												//
#endif																											//